#include "当康.h"

引入 当康::基础类;
引入 当康::包装类;
引入 当康::开发者;

命名空间 当康 {
命名空间 图形处理 {

类定义(当康::图形处理::帧缓冲区)

帧缓冲区& 帧缓冲区::构造() {
	日志::格式化打印日志(日志::调试信息, "帧缓冲区& 帧缓冲区::构造()\n");
	返回 本体;
}

void 帧缓冲区::析构() {
	如果 (帧缓冲 != 空指针)
		删除[] 帧缓冲;
	如果 (行缓冲 != 空指针)
		删除[] 行缓冲;
}

帧缓冲区& 帧缓冲区::构造(i32 宽度, i32 高度, i8 像素色深) {
	日志::格式化打印日志(日志::调试信息, "帧缓冲区& 帧缓冲区::构造(i32 宽度 = %d, i32 高度 = %d, i8 像素色深 = %d)\n", 宽度, 高度, 像素色深);

	本元->宽度 = 宽度;
	本元->高度 = 高度;
	本元->像素色深 = 像素色深;

	初始化缓冲区();

	日志::格式化打印日志(日志::调试信息, "完成 帧缓冲区& 帧缓冲区::构造(i32 宽度 = %d, i32 高度 = %d, i8 像素色深 = %d)\n", 宽度, 高度, 像素色深);

	返回 本体;
}

帧缓冲区& 帧缓冲区::复制构造(只读 帧缓冲区 &其他实例) {
	返回 本体;
}

帧缓冲区& 帧缓冲区::移动构造(帧缓冲区 &&其他实例) {
	返回 本体;
}

i32 帧缓冲区::获取宽度() 只读 {
	返回 宽度;
}

i32 帧缓冲区::获取高度() 只读 {
	返回 高度;
}

void 帧缓冲区::获取大小(i32 &宽度, i32 &高度) 只读 {
	宽度 = 本元->宽度;
	高度 = 本元->高度;
}

void 帧缓冲区::设置宽度(i32 宽度) {
	本元->宽度 = 宽度;
	初始化缓冲区();
}

void 帧缓冲区::设置高度(i32 高度) {
	本元->高度 = 高度;
	初始化缓冲区();
}

void 帧缓冲区::设置大小(i32 宽度, i32 高度) {
	本元->宽度 = 宽度;
	本元->高度 = 高度;
	初始化缓冲区();
}

i8 帧缓冲区::获取像素色深() 只读 {
	返回 像素色深;
}

void 帧缓冲区::设置像素色深(i8 像素色深) {
	本元->像素色深 = 像素色深;
	初始化缓冲区();
}

void 帧缓冲区::初始化缓冲区() {
	日志::格式化打印日志(日志::调试信息, "void 帧缓冲区::初始化缓冲区()\n");

	如果 (行缓冲区大小 == 宽度 * 像素色深 / 8 且 缓冲区大小 == 行缓冲区大小 * 高度)
		返回;

	// 参数设定
	行缓冲区大小 = 宽度 * 像素色深 / 8;
	缓冲区大小 = 行缓冲区大小 * 高度;

	日志::格式化打印日志(日志::调试信息, "\t参数设定: 行缓冲区大小 = %d, 缓冲区大小 = %d\n", 行缓冲区大小, 缓冲区大小);

	// 创建临时帧缓冲和行缓冲并将行缓冲映射到帧缓冲
	u8 *临时帧缓冲 = 创建 u8[缓冲区大小];
	u8 **临时行缓冲 = 创建 u8*[高度];

	日志::格式化打印日志(日志::调试信息, "\t临时帧缓冲 = 0x%016lx, 临时行缓冲 = 0x%016lx\n", 临时帧缓冲, 临时行缓冲);

	循环 (i32 i = 0; i < 高度; i++)
		临时行缓冲[i] = &(临时帧缓冲[行缓冲区大小 * i]);

	// 如果帧缓冲非空的话, 将其内容复制到临时帧缓冲
	如果 (帧缓冲 != 空指针)
		;

	// 交换缓冲区指针
	// 上锁
	交换(帧缓冲, 临时帧缓冲);
	交换(行缓冲, 临时行缓冲);
	// 解锁

	日志::格式化打印日志(日志::调试信息, "\t帧缓冲 = 0x%016lx, 行缓冲 = 0x%016lx\n", 帧缓冲, 行缓冲);
	日志::格式化打印日志(日志::调试信息, "\t临时帧缓冲 = 0x%016lx, 临时行缓冲 = 0x%016lx\n", 临时帧缓冲, 临时行缓冲);

	如果 (临时帧缓冲 != 空指针)
		删除[] 临时帧缓冲;

	如果 (临时行缓冲 != 空指针)
		删除[] 临时行缓冲;
}

i32 帧缓冲区::读像素点(i32 x, i32 y) 只读 {
	选择 (像素色深) {
	分支 8:
		返回 *(((u8*) ((行缓冲[y]))) + x);
	分支 16:
		返回 *(((u16*) ((行缓冲[y]))) + x);
	分支 24: {
		u8 *p = (((u8*) (行缓冲[y])) + 3 * x);
		返回 (*p << 16) | (*(p + 1) << 8) | *(p + 2);
	}
	分支 32:
		返回 *(((u32*) ((行缓冲[y]))) + x);
	默认:
		返回 0;
	}
}

void 帧缓冲区::写像素点(i32 x, i32 y, i32 值) {
	选择 (像素色深) {
	分支 8:
		*(((u8*) ((行缓冲[y]))) + x) = (u8) (值);
		跳出;
	分支 16:
		*(((u16*) ((行缓冲[y]))) + x) = (u16) (值);
		跳出;
	分支 24: {
		u8 *p = (((u8*) (行缓冲[y])) + 3 * x);
		*(p + 0) = 0xff & (值 >> 16);
		*(p + 1) = 0xff & (值 >> 8);
		*(p + 2) = 0xff & (值 >> 0);
		跳出;
	}
	分支 32:
		*(((u32*) ((行缓冲[y]))) + x) = (u32) (值);
		跳出;
	}
}

void 帧缓冲区::写行像素点(i32 x0, i32 y0, i32 宽度, i32 值) {
	i32 x1 = x0 + 宽度 - 1;

	循环 (i32 x = x0; x <= x1; x++)
		写像素点(x, y0, 值);
}

void 帧缓冲区::写列像素点(i32 x0, i32 y0, i32 高度, i32 值) {
	i32 y1 = y0 + 高度 - 1;

	循环 (i32 y = y0; y <= y1; y++)
		写像素点(x0, y, 值);
}

void 帧缓冲区::写矩形像素点(i32 x0, i32 y0, i32 宽度, i32 高度, i32 值) {
	i32 y1 = y0 + 高度 - 1;

	循环 (i32 y = y0; y <= y1; y++)
		写行像素点(x0, y, 宽度, 值);
}

void 帧缓冲区::清屏(i32 值) {
	日志::格式化打印日志(日志::调试信息, "void 帧缓冲区::清屏(i32 值 = %d)\n", 值);
	写矩形像素点(0, 0, 宽度, 高度, 值);
}

}
}
