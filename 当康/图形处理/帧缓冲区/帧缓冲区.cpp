#include "当康.h"

using namespace 当康::基础类;
using namespace 当康::包装类;
using namespace 当康::开发者;

namespace 当康 {
namespace 图形处理 {

类定义(当康::图形处理::帧缓冲区)

帧缓冲区& 帧缓冲区::构造() {
	日志::格式化打印日志(日志::调试信息, "帧缓冲区& 帧缓冲区::构造()\n");
	return (*this);
}

void 帧缓冲区::析构() {
	if (帧缓冲 != nullptr)
		delete[] 帧缓冲;
	if (行缓冲 != nullptr)
		delete[] 行缓冲;
}

帧缓冲区& 帧缓冲区::构造(i32 宽度, i32 高度, i32 像素色深) {
	日志::格式化打印日志(日志::调试信息, "帧缓冲区& 帧缓冲区::构造(i32 宽度 = %d, i32 高度 = %d, i8 像素色深 = %d)\n", 宽度, 高度, 像素色深);

	this->宽度 = 宽度;
	this->高度 = 高度;
	this->像素色深 = 像素色深;

	初始化缓冲区();

	日志::格式化打印日志(日志::调试信息, "完成 帧缓冲区& 帧缓冲区::构造(i32 宽度 = %d, i32 高度 = %d, i8 像素色深 = %d)\n", 宽度, 高度, 像素色深);

	return (*this);
}

帧缓冲区& 帧缓冲区::复制构造(const 帧缓冲区 &其他实例) {
	return (*this);
}

帧缓冲区& 帧缓冲区::移动构造(帧缓冲区 &&其他实例) {
	return (*this);
}

i32 帧缓冲区::获取宽度() const {
	return 宽度;
}

i32 帧缓冲区::获取高度() const {
	return 高度;
}

void 帧缓冲区::获取大小(i32 &宽度, i32 &高度) const {
	宽度 = this->宽度;
	高度 = this->高度;
}

void 帧缓冲区::设置宽度(i32 宽度) {
	this->宽度 = 宽度;
	初始化缓冲区();
}

void 帧缓冲区::设置高度(i32 高度) {
	this->高度 = 高度;
	初始化缓冲区();
}

void 帧缓冲区::设置大小(i32 宽度, i32 高度) {
	this->宽度 = 宽度;
	this->高度 = 高度;
	初始化缓冲区();
}

i32 帧缓冲区::获取像素色深() const {
	return 像素色深;
}

void 帧缓冲区::设置像素色深(i32 像素色深) {
	this->像素色深 = 像素色深;
	初始化缓冲区();
}

void 帧缓冲区::初始化缓冲区() {
	日志::格式化打印日志(日志::调试信息, "void 帧缓冲区::初始化缓冲区()\n");

	if (行缓冲区大小 == 宽度 * 像素色深 / 8 and 缓冲区大小 == 行缓冲区大小 * 高度)
		return;

	// 参数设定
	行缓冲区大小 = 宽度 * 像素色深 / 8;
	缓冲区大小 = 行缓冲区大小 * 高度;

	日志::格式化打印日志(日志::调试信息, "\t参数设定: 行缓冲区大小 = %d, 缓冲区大小 = %d\n", 行缓冲区大小, 缓冲区大小);

	// 创建临时帧缓冲和行缓冲并将行缓冲映射到帧缓冲
	u8 *临时帧缓冲 = new u8[缓冲区大小];
	u8 **临时行缓冲 = new u8*[高度];

	日志::格式化打印日志(日志::调试信息, "\t临时帧缓冲 = 0x%016lx, 临时行缓冲 = 0x%016lx\n", 临时帧缓冲, 临时行缓冲);

	for (i32 i = 0; i < 高度; i++)
		临时行缓冲[i] = &(临时帧缓冲[行缓冲区大小 * i]);

	// 如果帧缓冲非空的话, 将其内容复制到临时帧缓冲
	if (帧缓冲 != nullptr)
		;

	// 交换缓冲区指针
	// 上锁
	交换(帧缓冲, 临时帧缓冲);
	交换(行缓冲, 临时行缓冲);
	// 解锁

	日志::格式化打印日志(日志::调试信息, "\t帧缓冲 = 0x%016lx, 行缓冲 = 0x%016lx\n", 帧缓冲, 行缓冲);
	日志::格式化打印日志(日志::调试信息, "\t临时帧缓冲 = 0x%016lx, 临时行缓冲 = 0x%016lx\n", 临时帧缓冲, 临时行缓冲);

	if (临时帧缓冲 != nullptr)
		delete[] 临时帧缓冲;

	if (临时行缓冲 != nullptr)
		delete[] 临时行缓冲;
}

i32 帧缓冲区::读像素点(i32 x, i32 y) const {
	switch (像素色深) {
	case 8:
		return *(((u8*) ((行缓冲[y]))) + x);
	case 16:
		return *(((u16*) ((行缓冲[y]))) + x);
	case 24: {
		u8 *p = (((u8*) (行缓冲[y])) + 3 * x);
		return (*p << 16) | (*(p + 1) << 8) | *(p + 2);
	}
	case 32:
		return *(((u32*) ((行缓冲[y]))) + x);
	default:
		return 0;
	}
}

void 帧缓冲区::写像素点(i32 x, i32 y, i32 值) {
	switch (像素色深) {
	case 8:
		*(((u8*) ((行缓冲[y]))) + x) = (u8) (值);
		break;
	case 16:
		*(((u16*) ((行缓冲[y]))) + x) = (u16) (值);
		break;
	case 24: {
		u8 *p = (((u8*) (行缓冲[y])) + 3 * x);
		*(p + 0) = 0xff & (值 >> 16);
		*(p + 1) = 0xff & (值 >> 8);
		*(p + 2) = 0xff & (值 >> 0);
		break;
	}
	case 32:
		*(((u32*) ((行缓冲[y]))) + x) = (u32) (值);
		break;
	}
}

void 帧缓冲区::写行像素点(i32 x0, i32 y0, i32 宽度, i32 值) {
	i32 x1 = x0 + 宽度 - 1;

	for (i32 x = x0; x <= x1; x++)
		写像素点(x, y0, 值);
}

void 帧缓冲区::写列像素点(i32 x0, i32 y0, i32 高度, i32 值) {
	i32 y1 = y0 + 高度 - 1;

	for (i32 y = y0; y <= y1; y++)
		写像素点(x0, y, 值);
}

void 帧缓冲区::写矩形像素点(i32 x0, i32 y0, i32 宽度, i32 高度, i32 值) {
	i32 y1 = y0 + 高度 - 1;

	for (i32 y = y0; y <= y1; y++)
		写行像素点(x0, y, 宽度, 值);
}

void 帧缓冲区::清屏(i32 值) {
	写矩形像素点(0, 0, 宽度, 高度, 值);
}

}
}
