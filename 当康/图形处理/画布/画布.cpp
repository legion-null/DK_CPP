#include "当康.h"

引入 当康::基础类;
引入 当康::包装类;
引入 当康::开发者;

命名空间 当康 {
命名空间 图形处理 {

类定义(当康::图形处理::画布)

画布& 画布::构造() {
	日志::格式化打印日志(日志::调试信息, "画布& 画布::构造()\n");
	返回 本体;
}

void 画布::析构() {

}

画布& 画布::构造(i32 宽度, i32 高度, i32 像素色深, 图形::显示方向 方向) {
	日志::格式化打印日志(日志::调试信息, "画布& 画布::构造(i32 宽度 = %d, i32 高度 = %d, i32 像素色深 = %d, 图形::显示方向 方向 = %d)\n", 宽度, 高度, 像素色深, 方向);

	帧缓冲区::构造(宽度, 高度, 像素色深);
	设置画布方向(方向);

	日志::格式化打印日志(日志::调试信息, "完成 画布& 画布::构造(i32 宽度 = %d, i32 高度 = %d, i32 像素色深 = %d, 图形::显示方向 方向 = %d)\n", 宽度, 高度, 像素色深, 方向);

	返回 本体;
}

画布& 画布::复制构造(只读 画布 &其他实例) {
	返回 本体;
}

画布& 画布::移动构造(画布 &&其他实例) {
	返回 本体;
}

图形::显示方向 画布::获取画布方向() 只读 {
	返回 方向;
}

void 画布::设置画布方向(图形::显示方向 方向) {
	本元->方向 = 方向;
}

void 画布::像素点映射(i32 &x, i32 &y) {
	返回 图形::像素点映射(x, y, 宽度, 高度, 方向);
}

void 画布::像素点反映射(i32 &x, i32 &y) {
	返回 图形::像素点反映射(x, y, 宽度, 高度, 方向);
}

颜色 画布::获取像素点(i32 x, i32 y) {
	像素点反映射(x, y);
	返回 帧缓冲区::读像素点(x, y);
}

void 画布::绘制像素点(i32 x, i32 y, 只读 颜色 &颜色) {
	像素点反映射(x, y);
	返回 帧缓冲区::写像素点(x, y, 颜色.获取颜色值());
}

void 画布::绘制横线(i32 x0, i32 y0, i32 宽度, 只读 颜色 &颜色) {
	像素点反映射(x0, y0);

	选择 (方向) {
	分支 图形::显示方向::不旋转:
		返回 帧缓冲区::写行像素点(x0, y0, 宽度, 颜色.获取颜色值());
	分支 图形::显示方向::顺时针90度:
		返回 帧缓冲区::写列像素点(x0, y0, 宽度, 颜色.获取颜色值());
	分支 图形::显示方向::顺时针180度:
		返回 帧缓冲区::写行像素点(x0, y0, 宽度, 颜色.获取颜色值());
	分支 图形::显示方向::顺时针270度:
		返回 帧缓冲区::写列像素点(x0, y0, 宽度, 颜色.获取颜色值());
	}
}

void 画布::绘制竖线(i32 x0, i32 y0, i32 高度, 只读 颜色 &颜色) {
	像素点反映射(x0, y0);

	选择 (方向) {
	分支 图形::显示方向::不旋转:
		返回 帧缓冲区::写列像素点(x0, y0, 高度, 颜色.获取颜色值());
	分支 图形::显示方向::顺时针90度:
		返回 帧缓冲区::写行像素点(x0, y0, 高度, 颜色.获取颜色值());
	分支 图形::显示方向::顺时针180度:
		返回 帧缓冲区::写列像素点(x0, y0, 高度, 颜色.获取颜色值());
	分支 图形::显示方向::顺时针270度:
		返回 帧缓冲区::写行像素点(x0, y0, 高度, 颜色.获取颜色值());
	}
}

void 画布::填充矩形(i32 x0, i32 y0, i32 宽度, i32 高度, 只读 颜色 &颜色) {
	像素点反映射(x0, y0);

	选择 (方向) {
	分支 图形::显示方向::不旋转:
		返回 帧缓冲区::写矩形像素点(x0, y0, 宽度, 高度, 颜色.获取颜色值());
	分支 图形::显示方向::顺时针90度:
		返回 帧缓冲区::写矩形像素点(x0, y0, 高度, 宽度, 颜色.获取颜色值());
	分支 图形::显示方向::顺时针180度:
		返回 帧缓冲区::写矩形像素点(x0, y0, 宽度, 高度, 颜色.获取颜色值());
	分支 图形::显示方向::顺时针270度:
		返回 帧缓冲区::写矩形像素点(x0, y0, 高度, 宽度, 颜色.获取颜色值());
	}
}

void 画布::清屏(只读 颜色 &颜色) {
	返回 帧缓冲区::清屏(颜色.获取颜色值());
}

}
}
